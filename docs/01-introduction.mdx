--- 
slug: /
toc_min_heading_level: 2
toc_max_heading_level: 3
---
import Link from '@docusaurus/Link';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import useBaseUrl from '@docusaurus/useBaseUrl';
import Admonition from '@theme/Admonition';

# Introduction

> Gwen = [G]iven [W]hen Th[en]

Gwen is a [Gherkin](https://cucumber.io/docs/gherkin/reference/) interpreter for driving automated testing and robotic processing with feature specifications.

Automation is achieved through Gherkin bindings called [meta specs](/docs/meta), composed with the [Gwen DSL](/docs/dsl) and maintained alongside your feature files. An embedded [Selenium](https://www.selenium.dev/) engine executes each step in your features according to your meta to automate operations in browsers for you.

## Declare features

Declare [feature specs](https://cucumber.io/docs/gherkin/reference/) to describe how scenarios should behave.

<Admonition type="tip">
  <p>Write feature specs without giving any thought to automation.</p>
</Admonition>

Feature specs are used to communicate requirements in the language of your domain. They should clear, concise and declarative. For example, the following describes how adding items to a todo list should behave.

<Admonition type="note" title="Feature Spec">
<p>

*File: features/todo.feature*
```gherkin
Feature: Add todo items
 
  Scenario: Create todo list
    Given a new todo list
     When the following items are added
          | Item          |
          | Get the milk  |
          | Walk the dog  |
     Then the list will contain 2 items
```
</p>
</Admonition>

## Compose meta

Compose [meta specs](/docs/meta) with the [Gwen DSL](/docs/dsl) to formulate how scenarios will execute.

<Admonition type="tip">
  <p>Write meta specs with automation in mind (as if you were a robot).</p>
</Admonition>

Meta specs are used to describe execution and are written in Gherkin too. [Step definitions](/docs/meta#stepdefs) and bindings are defined in meta so your features remain clean and unconcerned with automation details.

For example, the following meta describes how the scenario in the feature above can be executed to automate a test against a running [todo application](https://todomvc.com/examples/react).

<Admonition type="note" title="Meta Spec">
<p>

*File: features/todo.meta*
```gherkin
Feature: Todo Meta

  @Context
  @StepDef
  Scenario: a new todo list
    Given my todo list can be located by css ".todo-list"
     When I navigate to "${todo.page.url}"
     Then the page title should contain "TodoMVC"
      And my todo list should be hidden

  @Action
  @StepDef
  @DataTable
  @ForEach
  Scenario: the following items are added
    Given the todo field can be located by class "new-todo"
     When I enter Item in the todo field
     Then my todo list should contain Item

  @Assertion
  @StepDef
  Scenario: the list will contain <expected-count> items
    Given the displayed count can be located by css ".todo-count strong"
     Then the displayed count should be "$<expected-count>"
```

</p>
</Admonition>

### Declaring step definitions

Each step definition is declared as a `@StepDef` annotated scenario with a name that matches that of the step in the feature it binds to. Each one calls out to one or more [DSL Steps](/docs/dsl/reference) (or potentially other StepDefs) in its body to perform the specified operations at run time.

The first StepDef in our meta example binds to the first step in the feature and will only execute when it is interpreted for execution by Gwen.

<Admonition type="note" title="Feature Step 1">
<p>

```gherkin
  Given a new todo list
```

</p>
</Admonition>

<Admonition type="note" title="StepDef 1">
<p>

```gherkin {2-3}
  @Context
  @StepDef
  Scenario: a new todo list
    Given my todo list can be located by css ".todo-list"
     When I navigate to "${todo.page.url}"
     Then the page title should contain "TodoMVC"
      And my todo list should be hidden
```

</p>
</Admonition>

### Web elements selectors

The first thing the above will do is bind the selector for locating the todo list element on the web page to the name `my todo list`. Later steps can then reference that element using this name to interact with it and Gwen will locate it dynamically.

<Admonition type="note" title="StepDef 1, Step 1">
<p>

```gherkin
  Given my todo list can be located by css ".todo-list"
```

Calls DSL step:

- [`<element> can be located by <selector> "<expression>"`](/docs/dsl/reference#element-can-be-located-by-selector-expression)

</p>
</Admonition>

<p> </p>

### Navigating to a web page

The next step in this StepDef will open a new browser window and navigate to the URL in the `todo.page.url` property.

<Admonition type="note" title="StepDef 1, Step 2">
<p>

```gherkin
  When I navigate to "${todo.page.url}"
```

Calls DSL step:

- [`I navigate to "<url>"`](/docs/dsl/reference#i-navigate-to-url)

</p>
</Admonition>

<p> </p>

### Accessing externalised properties

We could have just hard coded the https://todomvc.com/examples/react URL in the above step, but externalising it enables us to target different environments through [string interpolation](/docs/advanced/string-interpolation) without changing our meta. This is useful during development when you want to execute against a locally running instance of the application or during testing when it is running on a different host or port. With this approach you can define a [settings](/docs/settings) file per environment and assign the URL for that environment to the `todo.page.url` property in each file. Then when you want to target an environment, you pass the settings file for that environment to Gwen and the URL will be resolved accordingly.

<Admonition type="note" title="Properties">
<p>

*File: env/test.properties*
```properties
  # test instance url
  todo.page.url = https://todomvc.com/examples/react
```

</p>
</Admonition>

### Checking the page title

The next step in the same StepDef checks that the page title in the browser window contains the string literal "TodoMVC" in it. If it doesn't then an assertion error will be raised, otherwise execution will resume to the next step. It is generally a good idea when navigating to a page to verify that you did indeed land on that page before proceeding to interact with it. Checking the title is one way to do it which will suffice in this case.

<Admonition type="note" title="StepDef 1, Step 3">
<p>

```gherkin
  Then the page title should contain "TodoMVC"
```

Calls DSL step:

- [`the page title should[ not] <match> "<expression>"`](/docs/dsl/reference#the-page-title-should-match-expression)

</p>
</Admonition>

<p> </p>

### Verifying that an element is hidden from view

The last step in this StepDef verifies that the web element containing the current list of todo items is hidden from view. We expect it to not be displayed because we haven't added any items to it yet. Recall that we bound this element in the first step earlier to the name `my todo list`. So here we reference it by that name and if Gwen cannot see it on the page then execution will resume, otherwise an assertion error will be raised. 

<Admonition type="note" title="StepDef 1, Step 4">
<p>

```gherkin
  And my todo list should be hidden
```

Calls DSL step:

- [`<element> should[ not] be <state>`](/docs/dsl/reference#element-should-be-state)

</p>
</Admonition>

<p> </p>

### Processing records in data tables

The second StepDef uses the `@DataTable` and `@ForEach` annotations which work together to process each record in the [data table](/docs/advanced/data-tables) of the second step in the feature.

<Admonition type="note" title="Feature Step 2">
<p>

```gherkin
  When the following items are added
       | Item          |
       | Get the milk  |
       | Walk the dog  |
```

</p>
</Admonition>

<Admonition type="note" title="StepDef 2">
<p>

```gherkin {2-5}
  @Action
  @StepDef
  @DataTable
  @ForEach
  Scenario: the following items are added
    Given the todo field can be located by class "new-todo"
     When I enter Item in the todo field
     Then my todo list should contain Item
```

</p>
</Admonition>

Gwen will call the StepDef for each record in the table and bind each field value to its declared name in the header record. The second and third steps in this StepDef will enter each `Item` into the `todo field` and check that it was added to `my todo list`. This is the same `my todo list` that we earlier confirmed was absent when we opened the page in the browser. We reuse it here to check that it now contains and displays each item. If it does not, then an assertion error will be raised. 

<Admonition type="note" title="StepDef 2, Steps 2 and 3">
<p>

```gherkin
  When I enter Item in the todo field
  Then my todo list should contain Item
```

Calls DSL steps:

- [`I <enter|type> <textRef> in <element>`](/docs/dsl/reference#i-enter-or-type-text-ref-in-element)
- [`<element> should[ not] <match> <expressionRef>`](/docs/dsl/reference#element-should-match-expression-ref)

</p>
</Admonition>

<p> </p>

### Passing parameters to StepDefs

The last StepDef accepts the number of expected items from the last step in the feature into a parameter placeholder named `expected-count` and then uses that to assert its value against `the displayed count` on the page. In this example, the value 2 will passed as the parameter.

<Admonition type="note" title="Feature Step 3">
<p>

```gherkin
  Then the list will contain 2 items
```

</p>
</Admonition>

<Admonition type="note" title="StepDef 3">
<p>

```gherkin {2-3,5}
  @Assertion
  @StepDef
  Scenario: the list will contain <expected-count> items
    Given the displayed count can be located by css ".todo-count strong"
     Then the displayed count should be "$<expected-count>"
```

</p>
</Admonition>

### Behavioral rules and semantics

The following annotations on StepDefs are used to associate behavior types and enforce the following rules when the [`gwen.behavior.rules`](/docs/settings/reference#gwen-behavior-rules) setting is set to `strict`.

| StepDefs annotated with.. | can only bind steps tied to keyword.. | because..                      |
| :-----------------------: | :-----------------------------------: | :----------------------------- |
|       `@Context `         |                 Given                 | Givens imply context behavior  |
|       `@Action`           |                 When                  | Whens imply action behavior    |
|       `@Assertion`        |                 Then                  | Thens imply assertion behavior |

---

When binding to a step declared with `And`, `But`, or `*`, then the keyword in the first step in the chain of preceeding steps declared with either `Given`, `When` or `Then` will become the tying keyword. Should the topmost step in a chain be declared with `*`, then the tying keyword will be `Given`.

For example, the following binding will be permitted since the feature step is declared with the `Then` keyword and the StepDef is annotated with `@Assertion`.

<Admonition type="note" title="Feature Step 3">
<p>

```gherkin
  Then the list will contain 2 items
```

</p>
</Admonition>

<Admonition type="note" title="StepDef 3">
<p>

```gherkin {1}
  @Assertion
  @StepDef
  Scenario: the list will contain <expected-count> items
    Given the displayed count can be located by css ".todo-count strong"
     Then the displayed count should be "$<expected-count>"
```

</p>
</Admonition>

If we were to change the keyword in the feature step to `When` however, it would not only read poorly but would no longer imply `@Assertion` behavior and Gwen would report the violation. Similarly, if we were to change the behavior annotation on the StepDef to `@Context`, then that behavior would not be implied by the `Then` keyword declared in the feature step.

<Admonition type="info" title="Default Setting">
<p>
Strict rules are enabled by default since <Link to="/docs/gwen3">Gwen 3</Link>. In prior versions, lenient was the default, meaning that these and other rules like <b>Given-When-Then</b> order were not enforced.
</p>
</Admonition>

### Associative meta

When the [`gwen.associative.meta`](/docs/settings/reference#gwen-associative-meta) setting is enabled, Gwen will automatically associate and bind all same named feature and meta files discovered in a directory with each other. In the following case, the meta would be considered associative.

```
features/todo.feature
features/todo.meta
```

<Admonition type="info" title="Default Setting">
<p>
Associative meta is enabled by default since <Link to="/docs/gwen3">Gwen 3</Link>. In prior versions, all meta files discovered in a directory were unconditionally bound to all features in that directory and it's subdirectories.
</p>
</Admonition>

## Launch Gwen

Launch Gwen to bind your meta and execute your features to automate.

### Invoke the CLI to execute

The [CLI](/docs/cli) is used to launch Gwen and execute features. When launched on a directory, it will recursively discover and bind all meta and feature files in that directory and execute all the features. Any [settings files](/docs/settings) passed in will be loaded and all `${prop.name}` placeholder references throughout the meta and feature files will resolve during execution.

The example presented in this introduction would execute to automate a test.

<Tabs
  groupId="setup"
  defaultValue="project"
  values={[
    {label: 'Project', value: 'project'},
    {label: 'Standalone', value: 'standalone'}
  ]}>

  <TabItem value="project">

  <Tabs
  groupId="jstool"
  defaultValue="yarn"
  values={[
    {label: 'Yarn', value: 'yarn'},
    {label: 'npm', value: 'npm'},
    {label: 'pnpm', value: 'pnpm'}
  ]}>

  <TabItem value="yarn">

<Admonition type="note" title="Invoking Gwen">
<p>

  Execute feature in test environment (passing in test environment settings):

  ```shell
  yarn gwen -b -c gwen/env/test.conf gwen/features/todo.feature
  ```
  [Gwen CLI](/docs/cli)

</p>
</Admonition>

  </TabItem>

  <TabItem value="npm">

<Admonition type="note" title="Invoking Gwen">
<p>

  Execute feature in test environment (passing in test environment settings):

  ```shell
  npm run gwen -- -b -c gwen/env/test.conf gwen/features/todo.feature
  ```

  [Gwen CLI](/docs/cli)

</p>
</Admonition>

  </TabItem>

  <TabItem value="pnpm">

<Admonition type="note" title="Invoking Gwen">
<p>

  Execute feature in test environment (passing in test environment settings):

  ```shell
  pnpm gwen -b -c gwen/env/test.conf gwen/features/todo.feature
  ```

  [Gwen CLI](/docs/cli)

</p>
</Admonition>

  </TabItem>

  </Tabs>

  </TabItem>  

  <TabItem value="standalone">

<Admonition type="note" title="Invoking Gwen">
<p>
  
  Execute feature in test environment (passing in test environment settings):

  ```shell
  gwen -b -c env/test.conf features/todo.feature
  ```

  [Gwen CLI](/docs/cli)

</p>
</Admonition>

  </TabItem>

  </Tabs>

<Admonition type="tip" title="Testing & Robotics">
<p>
Your Gwen usage need not be confined to just testing. You can automate robotic processing too!
</p>
</Admonition>
